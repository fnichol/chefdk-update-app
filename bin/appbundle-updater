#!/usr/bin/env ruby
# -*- encoding: utf-8 -*-
#
# Author:: Fletcher Nichol (<fnichol@nichol.ca>)
#
# Copyright (C) 2015 Fletcher Nichol
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require "pathname"
require "optparse"
require "open-uri"
require "fileutils"
require "rubygems/package"
require "zlib"
require "tempfile"

# FIXME: move to helpers mixin

def windows?
  @windows ||= RUBY_PLATFORM =~ /mswin|mingw|windows/
end

def chefdk
  if windows?
    Pathname.new(File.join(ENV["SYSTEMDRIVE"], "opscode", ARGV[0]))
  else
    Pathname.new(File.join("/opt", ARGV[0]))
  end
end

def bin_dir
  chefdk.join("embedded/bin")
end

TAR_LONGLINK = '././@LongLink'

# pure ruby `tar xzf`, handles longlinks and directories ending in '/'
# (http://stackoverflow.com/a/31310593/506908)
def extract_tgz(file, destination = '.')
  Gem::Package::TarReader.new( Zlib::GzipReader.open file ) do |tar|
    dest = nil
    tar.each do |entry|
      if entry.full_name == TAR_LONGLINK
        dest = File.join destination, entry.read.strip
        next
      end
      dest ||= File.join destination, entry.full_name
      if entry.directory? || (entry.header.typeflag == '' && entry.full_name.end_with?('/'))
        File.delete dest if File.file? dest
        FileUtils.mkdir_p dest, :mode => entry.header.mode, :verbose => false
      elsif entry.file? || (entry.header.typeflag == '' && !entry.full_name.end_with?('/'))
        FileUtils.rm_rf dest if File.directory? dest
        File.open dest, "wb" do |f|
          f.print entry.read
        end
        FileUtils.chmod entry.header.mode, dest, :verbose => false
      elsif entry.header.typeflag == '2' #Symlink!
        File.symlink entry.header.linkname, dest
      else
        puts "Unkown tar entry: #{entry.full_name} type: #{entry.header.typeflag}."
      end
      dest = nil
    end
  end
end

App = Struct.new(:name, :repo, :bundle_without, :install_command) do
  def to_s
    name
  end
end

CHEFDK_APPS = [
  App.new(
    "berkshelf",
    "berkshelf/berkshelf",
    "guard test",
    "#{bin_dir.join("rake")} install",
  ),
  App.new(
    "chef",
    "chef/chef",
    "server docgen test development",
    "#{bin_dir.join("rake")} install",
  ),
  App.new(
    "chef-dk",
    "chef/chef-dk",
    "dev test development",
    "#{bin_dir.join("rake")} install",
  ),
  App.new(
    "chef-vault",
    "Nordstrom/chef-vault",
    "test",
    "#{bin_dir.join("rake")} install",
  ),
  App.new(
    "foodcritic",
    "acrmp/foodcritic",
    nil,
    "#{bin_dir.join("rake")} install",
  ),
  App.new(
    "ohai",
    "chef/ohai",
    "test development",
    "#{bin_dir.join("rake")} install",
  ),
  App.new(
    "test-kitchen",
    "test-kitchen/test-kitchen",
    "guard test",
    "#{bin_dir.join("rake")} install",
  )
].freeze

class Updater
  attr_reader :app, :ref

  def initialize(options)
    @app = options[:app]
    @ref = options[:ref]
  end

  def start
    if !windows? && Process.uid != 0
      abort "#{$0} needs to be run as root user or with sudo"
    end

    ruby("-rpp -e 'pp ENV'")
    banner("Cleaning #{app} checkout")
    app_dir.rmtree if app_dir.directory?

    git_url = "https://github.com/#{app.repo}/archive/#{ref}.tar.gz"
    banner("Extracting #{app} from #{git_url}")
    Dir.chdir(chefdk.join("embedded/apps")) do
      Tempfile.open('appbundle-updater') do |tempfile|
        open(git_url) do |uri|
          tempfile.write(uri.read)
        end
        tempfile.close
        extract_tgz(tempfile.path)
      end
      base = File.basename app.repo
      FileUtils.mv "#{base}-#{ref}", "#{app.name}"
    end

    banner("Installing dependencies")
    Dir.chdir(app_dir) do
      cmd = "#{bin_dir.join("bundle")} install"
      cmd += " --without #{app.bundle_without}" if app.bundle_without
      ruby(cmd)
    end

    banner("Installing gem")
    Dir.chdir(app_dir) do
      ruby("#{bin_dir.join("bundle")} exec #{app.install_command}")
    end

    banner("Updating appbundler binstubs for #{app}")
    Dir.chdir(app_dir) do
      ruby("#{bin_dir.join("appbundler")} #{app_dir} #{chefdk.join("bin")}")
    end

    banner("Finished!")
  end

  private
  ENV_KEYS = %w[
    BUNDLE_BIN_PATH BUNDLE_GEMFILE GEM_HOME GEM_PATH GEM_ROOT IRBRC MY_RUBY_HOME RUBYLIB RUBYOPT RUBY_ENGINE RUBY_ROOT RUBY_VERSION _ORIGINAL_GEM_PATH PATH
  ].freeze

  def app_dir
    chefdk.join("embedded/apps/#{app}")
  end

  def banner(msg)
    puts "-----> #{msg}"
  end

  def ruby(script)
    ruby = bin_dir.join("ruby").to_s.tap { |p| p.concat(".exe") if windows? }

    run([ruby, script].join(" "))
  end

  def run(cmd)
    ENV_KEYS.each { |key| ENV["_YOLO_#{key}"] = ENV[key]; ENV.delete(key) }
    ENV['PATH'] = "#{bin_dir}:#{ENV['_YOLO_PATH']}"
    puts "    running: #{cmd}"
    system(cmd) or raise("Command [#{cmd}] failed!")
    ENV_KEYS.each { |key| ENV[key] = ENV.delete("_YOLO_#{key}") }
  end

end

class CLI
  def self.options
    new.options
  end

  attr_reader :options, :parser

  def initialize
    @options = Hash.new
    @parser = OptionParser.new { |opts|
      opts.banner = "Usage: #{$0} PROJECT APP_NAME GIT_REF"
      opts.on("-h", "--help", "Prints this help") do
        puts opts
        exit
      end
      opts.separator("")
      opts.separator("App names:")
      CHEFDK_APPS.each { |a| opts.separator("    * #{a.name}") }
    }
    @parser.parse!
    validate!
  end

  def validate!
    die("PROJECT APP_NAME GIT_REF options are all required") if ARGV.length < 3
    options[:app] = CHEFDK_APPS.find { |a| a.name == ARGV[1] }
    die("Invalid APP_NAME: #{ARGV[1]}") if options[:app].nil?
    options[:ref] = ARGV[2]
  end

  def die(msg)
    $stderr.puts msg
    $stderr.puts parser
    exit 1
  end
end

Updater.new(CLI.options).start
